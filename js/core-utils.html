<script>
// ============================================================================
// BDPA - js/core-utils.html - Utilidades Globales
// ============================================================================

/**
 * Utilidades comunes para todo el sistema BDPA
 * Funciones auxiliares que resuelven problemas recurrentes
 */

/**
 * Formatear fecha - RESUELVE PROBLEMA RECURRENTE
 * @param {string|Date} fecha - Fecha a formatear
 * @param {string} formato - Formato deseado ('corta', 'larga', 'completa')
 * @returns {string} Fecha formateada
 */
function formatearFecha(fecha, formato = 'corta') {
    if (!fecha) return '-';
    
    try {
        const fechaObj = typeof fecha === 'string' ? new Date(fecha) : fecha;
        
        if (isNaN(fechaObj.getTime())) {
            return 'Fecha inválida';
        }
        
        const opciones = {
            'corta': {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit'
            },
            'larga': {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            },
            'completa': {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            }
        };
        
        const opcion = opciones[formato] || opciones.corta;
        return fechaObj.toLocaleDateString('es-CL', opcion);
        
    } catch (error) {
        console.error('[UTILS] Error formateando fecha:', error);
        return 'Error en fecha';
    }
}

/**
 * Generar ID único
 * @param {string} prefijo - Prefijo opcional
 * @returns {string} ID único
 */
function generarId(prefijo = '') {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substr(2, 9);
    return prefijo ? `${prefijo}_${timestamp}_${random}` : `${timestamp}_${random}`;
}

/**
 * Validar email
 * @param {string} email - Email a validar
 * @returns {boolean} True si es válido
 */
function validarEmail(email) {
    if (!email || typeof email !== 'string') return false;
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return regex.test(email.trim());
}

/**
 * Validar RUT chileno
 * @param {string} rut - RUT a validar
 * @returns {boolean} True si es válido
 */
function validarRUT(rut) {
    if (!rut || typeof rut !== 'string') return false;
    
    // Limpiar RUT
    rut = rut.replace(/[^0-9kK]/g, '').toUpperCase();
    
    if (rut.length < 2) return false;
    
    const cuerpo = rut.slice(0, -1);
    const dv = rut.slice(-1);
    
    // Calcular dígito verificador
    let suma = 0;
    let multiplicador = 2;
    
    for (let i = cuerpo.length - 1; i >= 0; i--) {
        suma += parseInt(cuerpo[i]) * multiplicador;
        multiplicador = multiplicador === 7 ? 2 : multiplicador + 1;
    }
    
    const resto = suma % 11;
    const dvCalculado = resto === 0 ? '0' : resto === 1 ? 'K' : (11 - resto).toString();
    
    return dv === dvCalculado;
}

/**
 * Formatear RUT
 * @param {string} rut - RUT a formatear
 * @returns {string} RUT formateado
 */
function formatearRUT(rut) {
    if (!rut) return '';
    
    // Limpiar RUT
    rut = rut.replace(/[^0-9kK]/g, '').toUpperCase();
    
    if (rut.length < 2) return rut;
    
    const cuerpo = rut.slice(0, -1);
    const dv = rut.slice(-1);
    
    // Formatear con puntos
    const cuerpoFormateado = cuerpo.replace(/\B(?=(\d{3})+(?!\d))/g, '.');
    
    return `${cuerpoFormateado}-${dv}`;
}

/**
 * Formatear número con separadores de miles
 * @param {number} numero - Número a formatear
 * @param {number} decimales - Cantidad de decimales
 * @returns {string} Número formateado
 */
function formatearNumero(numero, decimales = 0) {
    if (numero === null || numero === undefined || isNaN(numero)) {
        return '0';
    }
    
    return new Intl.NumberFormat('es-CL', {
        minimumFractionDigits: decimales,
        maximumFractionDigits: decimales
    }).format(numero);
}

/**
 * Formatear moneda chilena
 * @param {number} monto - Monto a formatear
 * @returns {string} Monto formateado
 */
function formatearMoneda(monto) {
    if (monto === null || monto === undefined || isNaN(monto)) {
        return '$0';
    }
    
    return new Intl.NumberFormat('es-CL', {
        style: 'currency',
        currency: 'CLP',
        minimumFractionDigits: 0
    }).format(monto);
}

/**
 * Capitalizar primera letra
 * @param {string} texto - Texto a capitalizar
 * @returns {string} Texto capitalizado
 */
function capitalizarPrimeraLetra(texto) {
    if (!texto || typeof texto !== 'string') return '';
    return texto.charAt(0).toUpperCase() + texto.slice(1).toLowerCase();
}

/**
 * Capitalizar cada palabra
 * @param {string} texto - Texto a capitalizar
 * @returns {string} Texto con cada palabra capitalizada
 */
function capitalizarPalabras(texto) {
    if (!texto || typeof texto !== 'string') return '';
    return texto.split(' ').map(palabra => capitalizarPrimeraLetra(palabra)).join(' ');
}

/**
 * Truncar texto
 * @param {string} texto - Texto a truncar
 * @param {number} longitud - Longitud máxima
 * @param {string} sufijo - Sufijo a agregar
 * @returns {string} Texto truncado
 */
function truncarTexto(texto, longitud = 50, sufijo = '...') {
    if (!texto || typeof texto !== 'string') return '';
    if (texto.length <= longitud) return texto;
    return texto.substring(0, longitud) + sufijo;
}

/**
 * Debounce para funciones
 * @param {Function} func - Función a ejecutar
 * @param {number} wait - Tiempo de espera en ms
 * @returns {Function} Función con debounce
 */
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

/**
 * Throttle para funciones
 * @param {Function} func - Función a ejecutar
 * @param {number} limit - Límite de tiempo en ms
 * @returns {Function} Función con throttle
 */
function throttle(func, limit) {
    let inThrottle;
    return function() {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
            func.apply(context, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

/**
 * Validar que un valor esté en un rango
 * @param {number} valor - Valor a validar
 * @param {number} min - Valor mínimo
 * @param {number} max - Valor máximo
 * @returns {boolean} True si está en rango
 */
function estaEnRango(valor, min, max) {
    return valor >= min && valor <= max;
}

/**
 * Obtener extensión de archivo
 * @param {string} nombreArchivo - Nombre del archivo
 * @returns {string} Extensión del archivo
 */
function obtenerExtensionArchivo(nombreArchivo) {
    if (!nombreArchivo || typeof nombreArchivo !== 'string') return '';
    const partes = nombreArchivo.split('.');
    return partes.length > 1 ? partes.pop().toLowerCase() : '';
}

/**
 * Validar tipo de archivo
 * @param {string} nombreArchivo - Nombre del archivo
 * @param {Array} tiposPermitidos - Array de extensiones permitidas
 * @returns {boolean} True si el tipo es permitido
 */
function validarTipoArchivo(nombreArchivo, tiposPermitidos) {
    const extension = obtenerExtensionArchivo(nombreArchivo);
    return tiposPermitidos.includes(extension);
}

/**
 * Formatear tamaño de archivo
 * @param {number} bytes - Tamaño en bytes
 * @returns {string} Tamaño formateado
 */
function formatearTamanoArchivo(bytes) {
    if (bytes === 0) return '0 Bytes';
    
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * Escapar HTML para prevenir XSS
 * @param {string} texto - Texto a escapar
 * @returns {string} Texto escapado
 */
function escaparHTML(texto) {
    if (!texto || typeof texto !== 'string') return '';
    
    const div = document.createElement('div');
    div.textContent = texto;
    return div.innerHTML;
}

/**
 * Generar color aleatorio
 * @returns {string} Color en formato hexadecimal
 */
function generarColorAleatorio() {
    return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
}

/**
 * Obtener contraste de color
 * @param {string} color - Color en formato hexadecimal
 * @returns {string} 'light' o 'dark'
 */
function obtenerContrasteColor(color) {
    // Remover # si existe
    color = color.replace('#', '');
    
    // Convertir a RGB
    const r = parseInt(color.substr(0, 2), 16);
    const g = parseInt(color.substr(2, 2), 16);
    const b = parseInt(color.substr(4, 2), 16);
    
    // Calcular luminancia
    const luminancia = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    
    return luminancia > 0.5 ? 'dark' : 'light';
}

/**
 * Copiar texto al portapapeles
 * @param {string} texto - Texto a copiar
 * @returns {Promise<boolean>} True si se copió exitosamente
 */
async function copiarAlPortapapeles(texto) {
    try {
        if (navigator.clipboard && window.isSecureContext) {
            await navigator.clipboard.writeText(texto);
            return true;
        } else {
            // Fallback para navegadores más antiguos
            const textArea = document.createElement('textarea');
            textArea.value = texto;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            const result = document.execCommand('copy');
            document.body.removeChild(textArea);
            return result;
        }
    } catch (error) {
        console.error('[UTILS] Error copiando al portapapeles:', error);
        return false;
    }
}

/**
 * Detectar si es dispositivo móvil
 * @returns {boolean} True si es móvil
 */
function esDispositivoMovil() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

/**
 * Obtener información del navegador
 * @returns {object} Información del navegador
 */
function obtenerInfoNavegador() {
    const ua = navigator.userAgent;
    let navegador = 'Desconocido';
    let version = 'Desconocida';
    
    if (ua.indexOf('Chrome') > -1) {
        navegador = 'Chrome';
        version = ua.match(/Chrome\/(\d+)/)?.[1] || 'Desconocida';
    } else if (ua.indexOf('Firefox') > -1) {
        navegador = 'Firefox';
        version = ua.match(/Firefox\/(\d+)/)?.[1] || 'Desconocida';
    } else if (ua.indexOf('Safari') > -1) {
        navegador = 'Safari';
        version = ua.match(/Version\/(\d+)/)?.[1] || 'Desconocida';
    } else if (ua.indexOf('Edge') > -1) {
        navegador = 'Edge';
        version = ua.match(/Edge\/(\d+)/)?.[1] || 'Desconocida';
    }
    
    return {
        navegador,
        version,
        userAgent: ua,
        esMovil: esDispositivoMovil()
    };
}

/**
 * Delay/sleep para funciones async
 * @param {number} ms - Milisegundos a esperar
 * @returns {Promise} Promise que se resuelve después del delay
 */
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Retry para funciones async
 * @param {Function} fn - Función a ejecutar
 * @param {number} maxRetries - Máximo número de reintentos
 * @param {number} delayMs - Delay entre reintentos
 * @returns {Promise} Resultado de la función
 */
async function retry(fn, maxRetries = 3, delayMs = 1000) {
    let lastError;
    
    for (let i = 0; i <= maxRetries; i++) {
        try {
            return await fn();
        } catch (error) {
            lastError = error;
            if (i < maxRetries) {
                await delay(delayMs);
            }
        }
    }
    
    throw lastError;
}

// ============================================================================
// EXPORTAR FUNCIONES GLOBALES
// ============================================================================

// Hacer disponibles las funciones globalmente
window.formatearFecha = formatearFecha;
window.generarId = generarId;
window.validarEmail = validarEmail;
window.validarRUT = validarRUT;
window.formatearRUT = formatearRUT;
window.formatearNumero = formatearNumero;
window.formatearMoneda = formatearMoneda;
window.capitalizarPrimeraLetra = capitalizarPrimeraLetra;
window.capitalizarPalabras = capitalizarPalabras;
window.truncarTexto = truncarTexto;
window.debounce = debounce;
window.throttle = throttle;
window.estaEnRango = estaEnRango;
window.obtenerExtensionArchivo = obtenerExtensionArchivo;
window.validarTipoArchivo = validarTipoArchivo;
window.formatearTamanoArchivo = formatearTamanoArchivo;
window.escaparHTML = escaparHTML;
window.generarColorAleatorio = generarColorAleatorio;
window.obtenerContrasteColor = obtenerContrasteColor;
window.copiarAlPortapapeles = copiarAlPortapapeles;
window.esDispositivoMovil = esDispositivoMovil;
window.obtenerInfoNavegador = obtenerInfoNavegador;
window.delay = delay;
window.retry = retry;

console.log('[UTILS] Archivo js/core-utils.html cargado completamente');
</script>